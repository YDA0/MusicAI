{"ast":null,"code":"import { Timeline } from \"./Timeline\";\nimport { assertRange } from \"./Debug\";\n/**\n * A Timeline State. Provides the methods: `setStateAtTime(\"state\", time)` and `getValueAtTime(time)`\n * @param initial The initial state of the StateTimeline.  Defaults to `undefined`\n */\nexport class StateTimeline extends Timeline {\n  constructor(initial = \"stopped\") {\n    super();\n    this.name = \"StateTimeline\";\n    this._initial = initial;\n    this.setStateAtTime(this._initial, 0);\n  }\n  /**\n   * Returns the scheduled state scheduled before or at\n   * the given time.\n   * @param  time  The time to query.\n   * @return  The name of the state input in setStateAtTime.\n   */\n  getValueAtTime(time) {\n    const event = this.get(time);\n    if (event !== null) {\n      return event.state;\n    } else {\n      return this._initial;\n    }\n  }\n  /**\n   * Add a state to the timeline.\n   * @param  state The name of the state to set.\n   * @param  time  The time to query.\n   * @param options Any additional options that are needed in the timeline.\n   */\n  setStateAtTime(state, time, options) {\n    assertRange(time, 0);\n    this.add(Object.assign({}, options, {\n      state,\n      time\n    }));\n    return this;\n  }\n  /**\n   * Return the event before the time with the given state\n   * @param  state The state to look for\n   * @param  time  When to check before\n   * @return  The event with the given state before the time\n   */\n  getLastState(state, time) {\n    // time = this.toSeconds(time);\n    const index = this._search(time);\n    for (let i = index; i >= 0; i--) {\n      const event = this._timeline[i];\n      if (event.state === state) {\n        return event;\n      }\n    }\n  }\n  /**\n   * Return the event after the time with the given state\n   * @param  state The state to look for\n   * @param  time  When to check from\n   * @return  The event with the given state after the time\n   */\n  getNextState(state, time) {\n    // time = this.toSeconds(time);\n    const index = this._search(time);\n    if (index !== -1) {\n      for (let i = index; i < this._timeline.length; i++) {\n        const event = this._timeline[i];\n        if (event.state === state) {\n          return event;\n        }\n      }\n    }\n  }\n}","map":{"version":3,"names":["Timeline","assertRange","StateTimeline","constructor","initial","name","_initial","setStateAtTime","getValueAtTime","time","event","get","state","options","add","Object","assign","getLastState","index","_search","i","_timeline","getNextState","length"],"sources":["../../../../Tone/core/util/StateTimeline.ts"],"sourcesContent":[null],"mappings":"AACA,SAASA,QAAQ,QAAuB,YAAY;AACpD,SAASC,WAAW,QAAQ,SAAS;AASrC;;;;AAIA,OAAM,MAAOC,aAAiD,SAAQF,QAAgD;EASrHG,YAAYC,OAAA,GAAyB,SAAS;IAC7C,KAAK,EAAE;IARC,KAAAC,IAAI,GAAW,eAAe;IAStC,IAAI,CAACC,QAAQ,GAAGF,OAAO;IACvB,IAAI,CAACG,cAAc,CAAC,IAAI,CAACD,QAAQ,EAAE,CAAC,CAAC;EACtC;EAEA;;;;;;EAMAE,cAAcA,CAACC,IAAa;IAC3B,MAAMC,KAAK,GAAG,IAAI,CAACC,GAAG,CAACF,IAAI,CAAC;IAC5B,IAAIC,KAAK,KAAK,IAAI,EAAE;MACnB,OAAOA,KAAK,CAACE,KAAK;KAClB,MAAM;MACN,OAAO,IAAI,CAACN,QAAQ;;EAEtB;EAEA;;;;;;EAMAC,cAAcA,CAACK,KAAoB,EAAEH,IAAa,EAAEI,OAA2B;IAC9EZ,WAAW,CAACQ,IAAI,EAAE,CAAC,CAAC;IACpB,IAAI,CAACK,GAAG,CAACC,MAAM,CAACC,MAAM,CAAC,EAAE,EAAEH,OAAO,EAAE;MACnCD,KAAK;MACLH;KACA,CAAC,CAAC;IACH,OAAO,IAAI;EACZ;EAEA;;;;;;EAMAQ,YAAYA,CAACL,KAAoB,EAAEH,IAAY;IAC9C;IACA,MAAMS,KAAK,GAAG,IAAI,CAACC,OAAO,CAACV,IAAI,CAAC;IAChC,KAAK,IAAIW,CAAC,GAAGF,KAAK,EAAEE,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAChC,MAAMV,KAAK,GAAG,IAAI,CAACW,SAAS,CAACD,CAAC,CAAC;MAC/B,IAAIV,KAAK,CAACE,KAAK,KAAKA,KAAK,EAAE;QAC1B,OAAOF,KAAK;;;EAGf;EAEA;;;;;;EAMAY,YAAYA,CAACV,KAAoB,EAAEH,IAAY;IAC9C;IACA,MAAMS,KAAK,GAAG,IAAI,CAACC,OAAO,CAACV,IAAI,CAAC;IAChC,IAAIS,KAAK,KAAK,CAAC,CAAC,EAAE;MACjB,KAAK,IAAIE,CAAC,GAAGF,KAAK,EAAEE,CAAC,GAAG,IAAI,CAACC,SAAS,CAACE,MAAM,EAAEH,CAAC,EAAE,EAAE;QACnD,MAAMV,KAAK,GAAG,IAAI,CAACW,SAAS,CAACD,CAAC,CAAC;QAC/B,IAAIV,KAAK,CAACE,KAAK,KAAKA,KAAK,EAAE;UAC1B,OAAOF,KAAK;;;;EAIhB"},"metadata":{},"sourceType":"module","externalDependencies":[]}