{"ast":null,"code":"import { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\nimport { EQ } from \"../util/Math\";\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\nexport class TickSource extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n    this.name = \"TickSource\";\n    /**\n     * The state timeline\n     */\n    this._state = new StateTimeline();\n    /**\n     * The offset values of the ticks\n     */\n    this._tickOffset = new Timeline();\n    const options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n    this.frequency = new TickSignal({\n      context: this.context,\n      units: options.units,\n      value: options.frequency\n    });\n    readOnly(this, \"frequency\");\n    // set the initial state\n    this._state.setStateAtTime(\"stopped\", 0);\n    // add the first event\n    this.setTicksAtTime(0, 0);\n  }\n  static getDefaults() {\n    return Object.assign({\n      frequency: 1,\n      units: \"hertz\"\n    }, ToneWithContext.getDefaults());\n  }\n  /**\n   * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n   */\n  get state() {\n    return this.getStateAtTime(this.now());\n  }\n  /**\n   * Start the clock at the given time. Optionally pass in an offset\n   * of where to start the tick counter from.\n   * @param  time    The time the clock should start\n   * @param offset The number of ticks to start the source at\n   */\n  start(time, offset) {\n    const computedTime = this.toSeconds(time);\n    if (this._state.getValueAtTime(computedTime) !== \"started\") {\n      this._state.setStateAtTime(\"started\", computedTime);\n      if (isDefined(offset)) {\n        this.setTicksAtTime(offset, computedTime);\n      }\n    }\n    return this;\n  }\n  /**\n   * Stop the clock. Stopping the clock resets the tick counter to 0.\n   * @param time The time when the clock should stop.\n   */\n  stop(time) {\n    const computedTime = this.toSeconds(time);\n    // cancel the previous stop\n    if (this._state.getValueAtTime(computedTime) === \"stopped\") {\n      const event = this._state.get(computedTime);\n      if (event && event.time > 0) {\n        this._tickOffset.cancel(event.time);\n        this._state.cancel(event.time);\n      }\n    }\n    this._state.cancel(computedTime);\n    this._state.setStateAtTime(\"stopped\", computedTime);\n    this.setTicksAtTime(0, computedTime);\n    return this;\n  }\n  /**\n   * Pause the clock. Pausing does not reset the tick counter.\n   * @param time The time when the clock should stop.\n   */\n  pause(time) {\n    const computedTime = this.toSeconds(time);\n    if (this._state.getValueAtTime(computedTime) === \"started\") {\n      this._state.setStateAtTime(\"paused\", computedTime);\n    }\n    return this;\n  }\n  /**\n   * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n   * @param time When to clear the events after\n   */\n  cancel(time) {\n    time = this.toSeconds(time);\n    this._state.cancel(time);\n    this._tickOffset.cancel(time);\n    return this;\n  }\n  /**\n   * Get the elapsed ticks at the given time\n   * @param  time  When to get the tick value\n   * @return The number of ticks\n   */\n  getTicksAtTime(time) {\n    const computedTime = this.toSeconds(time);\n    const stopEvent = this._state.getLastState(\"stopped\", computedTime);\n    // this event allows forEachBetween to iterate until the current time\n    const tmpEvent = {\n      state: \"paused\",\n      time: computedTime\n    };\n    this._state.add(tmpEvent);\n    // keep track of the previous offset event\n    let lastState = stopEvent;\n    let elapsedTicks = 0;\n    // iterate through all the events since the last stop\n    this._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, e => {\n      let periodStartTime = lastState.time;\n      // if there is an offset event in this period use that\n      const offsetEvent = this._tickOffset.get(e.time);\n      if (offsetEvent && offsetEvent.time >= lastState.time) {\n        elapsedTicks = offsetEvent.ticks;\n        periodStartTime = offsetEvent.time;\n      }\n      if (lastState.state === \"started\" && e.state !== \"started\") {\n        elapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n      }\n      lastState = e;\n    });\n    // remove the temporary event\n    this._state.remove(tmpEvent);\n    // return the ticks\n    return elapsedTicks;\n  }\n  /**\n   * The number of times the callback was invoked. Starts counting at 0\n   * and increments after the callback was invoked. Returns -1 when stopped.\n   */\n  get ticks() {\n    return this.getTicksAtTime(this.now());\n  }\n  set ticks(t) {\n    this.setTicksAtTime(t, this.now());\n  }\n  /**\n   * The time since ticks=0 that the TickSource has been running. Accounts\n   * for tempo curves\n   */\n  get seconds() {\n    return this.getSecondsAtTime(this.now());\n  }\n  set seconds(s) {\n    const now = this.now();\n    const ticks = this.frequency.timeToTicks(s, now);\n    this.setTicksAtTime(ticks, now);\n  }\n  /**\n   * Return the elapsed seconds at the given time.\n   * @param  time  When to get the elapsed seconds\n   * @return  The number of elapsed seconds\n   */\n  getSecondsAtTime(time) {\n    time = this.toSeconds(time);\n    const stopEvent = this._state.getLastState(\"stopped\", time);\n    // this event allows forEachBetween to iterate until the current time\n    const tmpEvent = {\n      state: \"paused\",\n      time\n    };\n    this._state.add(tmpEvent);\n    // keep track of the previous offset event\n    let lastState = stopEvent;\n    let elapsedSeconds = 0;\n    // iterate through all the events since the last stop\n    this._state.forEachBetween(stopEvent.time, time + this.sampleTime, e => {\n      let periodStartTime = lastState.time;\n      // if there is an offset event in this period use that\n      const offsetEvent = this._tickOffset.get(e.time);\n      if (offsetEvent && offsetEvent.time >= lastState.time) {\n        elapsedSeconds = offsetEvent.seconds;\n        periodStartTime = offsetEvent.time;\n      }\n      if (lastState.state === \"started\" && e.state !== \"started\") {\n        elapsedSeconds += e.time - periodStartTime;\n      }\n      lastState = e;\n    });\n    // remove the temporary event\n    this._state.remove(tmpEvent);\n    // return the ticks\n    return elapsedSeconds;\n  }\n  /**\n   * Set the clock's ticks at the given time.\n   * @param  ticks The tick value to set\n   * @param  time  When to set the tick value\n   */\n  setTicksAtTime(ticks, time) {\n    time = this.toSeconds(time);\n    this._tickOffset.cancel(time);\n    this._tickOffset.add({\n      seconds: this.frequency.getDurationOfTicks(ticks, time),\n      ticks,\n      time\n    });\n    return this;\n  }\n  /**\n   * Returns the scheduled state at the given time.\n   * @param  time  The time to query.\n   */\n  getStateAtTime(time) {\n    time = this.toSeconds(time);\n    return this._state.getValueAtTime(time);\n  }\n  /**\n   * Get the time of the given tick. The second argument\n   * is when to test before. Since ticks can be set (with setTicksAtTime)\n   * there may be multiple times for a given tick value.\n   * @param  tick The tick number.\n   * @param  before When to measure the tick value from.\n   * @return The time of the tick\n   */\n  getTimeOfTick(tick, before = this.now()) {\n    const offset = this._tickOffset.get(before);\n    const event = this._state.get(before);\n    const startTime = Math.max(offset.time, event.time);\n    const absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n    return this.frequency.getTimeOfTick(absoluteTicks);\n  }\n  /**\n   * Invoke the callback event at all scheduled ticks between the\n   * start time and the end time\n   * @param  startTime  The beginning of the search range\n   * @param  endTime    The end of the search range\n   * @param  callback   The callback to invoke with each tick\n   */\n  forEachTickBetween(startTime, endTime, callback) {\n    // only iterate through the sections where it is \"started\"\n    let lastStateEvent = this._state.get(startTime);\n    this._state.forEachBetween(startTime, endTime, event => {\n      if (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n        this.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - this.sampleTime, callback);\n      }\n      lastStateEvent = event;\n    });\n    let error = null;\n    if (lastStateEvent && lastStateEvent.state === \"started\") {\n      const maxStartTime = Math.max(lastStateEvent.time, startTime);\n      // figure out the difference between the frequency ticks and the\n      const startTicks = this.frequency.getTicksAtTime(maxStartTime);\n      const ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n      const diff = startTicks - ticksAtStart;\n      let offset = Math.ceil(diff) - diff;\n      // guard against floating point issues\n      offset = EQ(offset, 1) ? 0 : offset;\n      let nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n      while (nextTickTime < endTime) {\n        try {\n          callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n        } catch (e) {\n          error = e;\n          break;\n        }\n        nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n      }\n    }\n    if (error) {\n      throw error;\n    }\n    return this;\n  }\n  /**\n   * Clean up\n   */\n  dispose() {\n    super.dispose();\n    this._state.dispose();\n    this._tickOffset.dispose();\n    this.frequency.dispose();\n    return this;\n  }\n}","map":{"version":3,"names":["ToneWithContext","optionsFromArguments","readOnly","StateTimeline","Timeline","isDefined","TickSignal","EQ","TickSource","constructor","getDefaults","arguments","name","_state","_tickOffset","options","frequency","context","units","value","setStateAtTime","setTicksAtTime","Object","assign","state","getStateAtTime","now","start","time","offset","computedTime","toSeconds","getValueAtTime","stop","event","get","cancel","pause","getTicksAtTime","stopEvent","getLastState","tmpEvent","add","lastState","elapsedTicks","forEachBetween","sampleTime","e","periodStartTime","offsetEvent","ticks","remove","t","seconds","getSecondsAtTime","s","timeToTicks","elapsedSeconds","getDurationOfTicks","getTimeOfTick","tick","before","startTime","Math","max","absoluteTicks","forEachTickBetween","endTime","callback","lastStateEvent","error","maxStartTime","startTicks","ticksAtStart","diff","ceil","nextTickTime","round","dispose"],"sources":["../../../../Tone/core/clock/TickSource.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}