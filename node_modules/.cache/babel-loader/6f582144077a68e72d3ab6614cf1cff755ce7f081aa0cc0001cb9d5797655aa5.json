{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Tone } from \"../Tone\";\nimport { optionsFromArguments } from \"./Defaults\";\nimport { assert } from \"./Debug\";\nimport { EQ, GT, GTE, LT } from \"./Math\";\n/**\n * A Timeline class for scheduling and maintaining state\n * along a timeline. All events must have a \"time\" property.\n * Internally, events are stored in time order for fast\n * retrieval.\n */\nexport class Timeline extends Tone {\n  constructor() {\n    super();\n    this.name = \"Timeline\";\n    /**\n     * The array of scheduled timeline events\n     */\n    this._timeline = [];\n    const options = optionsFromArguments(Timeline.getDefaults(), arguments, [\"memory\"]);\n    this.memory = options.memory;\n    this.increasing = options.increasing;\n  }\n  static getDefaults() {\n    return {\n      memory: Infinity,\n      increasing: false\n    };\n  }\n  /**\n   * The number of items in the timeline.\n   */\n  get length() {\n    return this._timeline.length;\n  }\n  /**\n   * Insert an event object onto the timeline. Events must have a \"time\" attribute.\n   * @param event  The event object to insert into the timeline.\n   */\n  add(event) {\n    // the event needs to have a time attribute\n    assert(Reflect.has(event, \"time\"), \"Timeline: events must have a time attribute\");\n    event.time = event.time.valueOf();\n    if (this.increasing && this.length) {\n      const lastValue = this._timeline[this.length - 1];\n      assert(GTE(event.time, lastValue.time), \"The time must be greater than or equal to the last scheduled time\");\n      this._timeline.push(event);\n    } else {\n      const index = this._search(event.time);\n      this._timeline.splice(index + 1, 0, event);\n    }\n    // if the length is more than the memory, remove the previous ones\n    if (this.length > this.memory) {\n      const diff = this.length - this.memory;\n      this._timeline.splice(0, diff);\n    }\n    return this;\n  }\n  /**\n   * Remove an event from the timeline.\n   * @param  {Object}  event  The event object to remove from the list.\n   * @returns {Timeline} this\n   */\n  remove(event) {\n    const index = this._timeline.indexOf(event);\n    if (index !== -1) {\n      this._timeline.splice(index, 1);\n    }\n    return this;\n  }\n  /**\n   * Get the nearest event whose time is less than or equal to the given time.\n   * @param  time  The time to query.\n   */\n  get(time, param = \"time\") {\n    const index = this._search(time, param);\n    if (index !== -1) {\n      return this._timeline[index];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Return the first event in the timeline without removing it\n   * @returns {Object} The first event object\n   */\n  peek() {\n    return this._timeline[0];\n  }\n  /**\n   * Return the first event in the timeline and remove it\n   */\n  shift() {\n    return this._timeline.shift();\n  }\n  /**\n   * Get the event which is scheduled after the given time.\n   * @param  time  The time to query.\n   */\n  getAfter(time, param = \"time\") {\n    const index = this._search(time, param);\n    if (index + 1 < this._timeline.length) {\n      return this._timeline[index + 1];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Get the event before the event at the given time.\n   * @param  time  The time to query.\n   */\n  getBefore(time) {\n    const len = this._timeline.length;\n    // if it's after the last item, return the last item\n    if (len > 0 && this._timeline[len - 1].time < time) {\n      return this._timeline[len - 1];\n    }\n    const index = this._search(time);\n    if (index - 1 >= 0) {\n      return this._timeline[index - 1];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Cancel events at and after the given time\n   * @param  after  The time to query.\n   */\n  cancel(after) {\n    if (this._timeline.length > 1) {\n      let index = this._search(after);\n      if (index >= 0) {\n        if (EQ(this._timeline[index].time, after)) {\n          // get the first item with that time\n          for (let i = index; i >= 0; i--) {\n            if (EQ(this._timeline[i].time, after)) {\n              index = i;\n            } else {\n              break;\n            }\n          }\n          this._timeline = this._timeline.slice(0, index);\n        } else {\n          this._timeline = this._timeline.slice(0, index + 1);\n        }\n      } else {\n        this._timeline = [];\n      }\n    } else if (this._timeline.length === 1) {\n      // the first item's time\n      if (GTE(this._timeline[0].time, after)) {\n        this._timeline = [];\n      }\n    }\n    return this;\n  }\n  /**\n   * Cancel events before or equal to the given time.\n   * @param  time  The time to cancel before.\n   */\n  cancelBefore(time) {\n    const index = this._search(time);\n    if (index >= 0) {\n      this._timeline = this._timeline.slice(index + 1);\n    }\n    return this;\n  }\n  /**\n   * Returns the previous event if there is one. null otherwise\n   * @param  event The event to find the previous one of\n   * @return The event right before the given event\n   */\n  previousEvent(event) {\n    const index = this._timeline.indexOf(event);\n    if (index > 0) {\n      return this._timeline[index - 1];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Does a binary search on the timeline array and returns the\n   * nearest event index whose time is after or equal to the given time.\n   * If a time is searched before the first index in the timeline, -1 is returned.\n   * If the time is after the end, the index of the last item is returned.\n   */\n  _search(time, param = \"time\") {\n    if (this._timeline.length === 0) {\n      return -1;\n    }\n    let beginning = 0;\n    const len = this._timeline.length;\n    let end = len;\n    if (len > 0 && this._timeline[len - 1][param] <= time) {\n      return len - 1;\n    }\n    while (beginning < end) {\n      // calculate the midpoint for roughly equal partition\n      let midPoint = Math.floor(beginning + (end - beginning) / 2);\n      const event = this._timeline[midPoint];\n      const nextEvent = this._timeline[midPoint + 1];\n      if (EQ(event[param], time)) {\n        // choose the last one that has the same time\n        for (let i = midPoint; i < this._timeline.length; i++) {\n          const testEvent = this._timeline[i];\n          if (EQ(testEvent[param], time)) {\n            midPoint = i;\n          } else {\n            break;\n          }\n        }\n        return midPoint;\n      } else if (LT(event[param], time) && GT(nextEvent[param], time)) {\n        return midPoint;\n      } else if (GT(event[param], time)) {\n        // search lower\n        end = midPoint;\n      } else {\n        // search upper\n        beginning = midPoint + 1;\n      }\n    }\n    return -1;\n  }\n  /**\n   * Internal iterator. Applies extra safety checks for\n   * removing items from the array.\n   */\n  _iterate(callback, lowerBound = 0, upperBound = this._timeline.length - 1) {\n    this._timeline.slice(lowerBound, upperBound + 1).forEach(callback);\n  }\n  /**\n   * Iterate over everything in the array\n   * @param  callback The callback to invoke with every item\n   */\n  forEach(callback) {\n    this._iterate(callback);\n    return this;\n  }\n  /**\n   * Iterate over everything in the array at or before the given time.\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n  forEachBefore(time, callback) {\n    // iterate over the items in reverse so that removing an item doesn't break things\n    const upperBound = this._search(time);\n    if (upperBound !== -1) {\n      this._iterate(callback, 0, upperBound);\n    }\n    return this;\n  }\n  /**\n   * Iterate over everything in the array after the given time.\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n  forEachAfter(time, callback) {\n    // iterate over the items in reverse so that removing an item doesn't break things\n    const lowerBound = this._search(time);\n    this._iterate(callback, lowerBound + 1);\n    return this;\n  }\n  /**\n   * Iterate over everything in the array between the startTime and endTime.\n   * The timerange is inclusive of the startTime, but exclusive of the endTime.\n   * range = [startTime, endTime).\n   * @param  startTime The time to check if items are before\n   * @param  endTime The end of the test interval.\n   * @param  callback The callback to invoke with every item\n   */\n  forEachBetween(startTime, endTime, callback) {\n    let lowerBound = this._search(startTime);\n    let upperBound = this._search(endTime);\n    if (lowerBound !== -1 && upperBound !== -1) {\n      if (this._timeline[lowerBound].time !== startTime) {\n        lowerBound += 1;\n      }\n      // exclusive of the end time\n      if (this._timeline[upperBound].time === endTime) {\n        upperBound -= 1;\n      }\n      this._iterate(callback, lowerBound, upperBound);\n    } else if (lowerBound === -1) {\n      this._iterate(callback, 0, upperBound);\n    }\n    return this;\n  }\n  /**\n   * Iterate over everything in the array at or after the given time. Similar to\n   * forEachAfter, but includes the item(s) at the given time.\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n  forEachFrom(time, callback) {\n    // iterate over the items in reverse so that removing an item doesn't break things\n    let lowerBound = this._search(time);\n    // work backwards until the event time is less than time\n    while (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {\n      lowerBound--;\n    }\n    this._iterate(callback, lowerBound + 1);\n    return this;\n  }\n  /**\n   * Iterate over everything in the array at the given time\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n  forEachAtTime(time, callback) {\n    // iterate over the items in reverse so that removing an item doesn't break things\n    const upperBound = this._search(time);\n    if (upperBound !== -1 && EQ(this._timeline[upperBound].time, time)) {\n      let lowerBound = upperBound;\n      for (let i = upperBound; i >= 0; i--) {\n        if (EQ(this._timeline[i].time, time)) {\n          lowerBound = i;\n        } else {\n          break;\n        }\n      }\n      this._iterate(event => {\n        callback(event);\n      }, lowerBound, upperBound);\n    }\n    return this;\n  }\n  /**\n   * Clean up.\n   */\n  dispose() {\n    super.dispose();\n    this._timeline = [];\n    return this;\n  }\n}","map":{"version":3,"names":["Tone","optionsFromArguments","assert","EQ","GT","GTE","LT","Timeline","constructor","name","_timeline","options","getDefaults","arguments","memory","increasing","Infinity","length","add","event","Reflect","has","time","valueOf","lastValue","push","index","_search","splice","diff","remove","indexOf","get","param","peek","shift","getAfter","getBefore","len","cancel","after","i","slice","cancelBefore","previousEvent","beginning","end","midPoint","Math","floor","nextEvent","testEvent","_iterate","callback","lowerBound","upperBound","forEach","forEachBefore","forEachAfter","forEachBetween","startTime","endTime","forEachFrom","forEachAtTime","dispose"],"sources":["../../../../Tone/core/util/Timeline.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}